<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RUNE // FIBONACCI AUDIO</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: monospace; }
        
        /* START OVERLAY */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 10;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer;
        }
        
        h1 { color: #d4af37; letter-spacing: 5px; font-size: 2rem; margin-bottom: 10px; }
        p { color: #666; }
        
        .hidden { opacity: 0; pointer-events: none; transition: opacity 0.5s; }
    </style>
    
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="overlay" onclick="startAudio()">
        <h1>FIBONACCI SEQUENCE</h1>
        <p>[ CLICK TO AUTHORIZE AUDIO STREAM ]</p>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // 1. SETUP SCENE
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 150;
        camera.position.y = -50;
        camera.rotation.x = 0.5;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. THE FIBONACCI SPIRAL (Phyllotaxis)
        const count = 2000;
        const geometry = new THREE.BoxGeometry(1, 1, 5);
        // We use InstancedMesh for performance (2000 items, 1 draw call)
        const mesh = new THREE.InstancedMesh(geometry, new THREE.MeshBasicMaterial({ color: 0xffffff }), count);
        
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();
        const goldenAngle = 137.508; // The Magic Number

        // Initial Positioning
        for (let i = 0; i < count; i++) {
            const angle = i * goldenAngle * (Math.PI / 180);
            const radius = 3 * Math.sqrt(i);
            
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const z = 0;

            dummy.position.set(x, y, z);
            dummy.lookAt(0, 0, 0); // Look at center
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
            
            // Gradient Colors (Gold to Obsidian)
            color.setHSL(0.1 + (i/count)*0.1, 1, 0.5); // Gold Hues
            mesh.setColorAt(i, color);
        }

        scene.add(mesh);

        // 3. AUDIO SYSTEM
        let analyser, dataArray;
        let audioActive = false;

        window.startAudio = async () => {
            document.getElementById('overlay').classList.add('hidden');
            
            try {
                // Get Microphone Access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaStreamSource(stream);
                
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; // Resolution
                source.connect(analyser);
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                audioActive = true;
            } catch (err) {
                alert("Microphone access denied. Visualization will be idle.");
            }
        };

        // 4. ANIMATION LOOP
        function animate() {
            requestAnimationFrame(animate);

            // Rotate the whole spiral slowly
            mesh.rotation.z -= 0.002;

            if (audioActive) {
                // Get Audio Data (0 to 255)
                analyser.getByteFrequencyData(dataArray);
                
                // Update Particles based on Audio
                for (let i = 0; i < count; i++) {
                    // Map particle index to a frequency band
                    // Low index = Bass, High index = Treble
                    // We map 2000 particles to the lower spectrum where the energy usually is
                    const freqIndex = Math.floor((i / count) * 100); 
                    const value = dataArray[freqIndex]; // 0 - 255
                    
                    // Recalculate Position based on original math
                    const angle = i * goldenAngle * (Math.PI / 180);
                    const radius = 3 * Math.sqrt(i);
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    
                    // Z-Axis Pulse (The Beat)
                    const z = (value / 255) * 50; 
                    
                    dummy.position.set(x, y, z);
                    dummy.lookAt(0, 0, 0);
                    
                    // Scale Effect (Bass makes them thicker)
                    const scale = 1 + (value / 255) * 4;
                    dummy.scale.set(1, 1, scale);
                    
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    // Color Shift on Volume
                    // If loud, turn Bright Gold/White. If quiet, Dark Gold.
                    const intensity = value / 255;
                    color.setHSL(0.12, 1, 0.1 + (intensity * 0.8));
                    mesh.setColorAt(i, color);
                }
                mesh.instanceMatrix.needsUpdate = true;
                mesh.instanceColor.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>